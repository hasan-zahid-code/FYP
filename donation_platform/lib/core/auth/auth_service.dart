import 'dart:async';
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:flutter_secure_storage/flutter_secure_storage.dart';
import 'package:donation_platform/data/models/user/user.dart';
import 'package:donation_platform/data/models/user/user_verification.dart';
import 'package:donation_platform/data/repositories/user_repository.dart';
import 'package:donation_platform/core/utils/exceptions.dart';
import 'package:donation_platform/config/constants.dart';
import 'package:crypto/crypto.dart';
import 'dart:convert';

class AuthService {
  final SupabaseClient _supabase = Supabase.instance.client;
  final UserRepository _userRepository;
  final FlutterSecureStorage _secureStorage = const FlutterSecureStorage();

  AuthService(this._userRepository);

  Future<AppUser?> getCurrentUser() async {
    try {
      final session = _supabase.auth.currentSession;
      if (session == null) {
        return null;
      }

      return await _userRepository.getUserById(session.user.id);
    } catch (e) {
      return null;
    }
  }

  // Helper method to hash passwords
  String _hashPassword(String password) {
    final bytes = utf8.encode(password);
    final hash = sha256.convert(bytes);
    return '\$2a\$12\$${hash.toString()}'; // Adding bcrypt prefix for compatibility
  }

  Future<AppUser> registerUser({
    required String email,
    required String password,
    required String fullName,
    required String phone,
    required String userType,
  }) async {
    try {
      // Register with Supabase Auth
      final response = await _supabase.auth.signUp(
        email: email,
        password: password,
        data: {
          'full_name': fullName,
          'phone': phone,
          'user_type': userType,
        },
      );

      if (response.user == null) {
        throw AppAuthException('Failed to register user');
      }

      // Generate a password hash to store in the database
      final passwordHash = _hashPassword(password);

      // Create user in database
      final user = AppUser(
        id: response.user!.id,
        email: email,
        phone: phone,
        fullName: fullName,
        isVerified: false,
        isActive: true,
        userType: userType,
        createdAt: DateTime.now(),
        updatedAt: DateTime.now(),
        verification: UserVerification(
          id: '', // Will be generated by the database
          userId: response.user!.id,
          cnicVerified: false,
          phoneVerified: false,
          isBlacklisted: false,
          createdAt: DateTime.now(),
          updatedAt: DateTime.now(),
        ),
      );

      // Include the password hash when creating the user in the database
      await _userRepository.createUser(user, passwordHash: passwordHash);
      return user;
    } catch (e) {
      if (e is AppAuthException) {
        rethrow;
      }
      throw AppAuthException(e.toString());
    }
  }

  Future<AppUser> loginUser({
    required String email,
    required String password,
  }) async {
    try {
      final response = await _supabase.auth.signInWithPassword(
        email: email,
        password: password,
      );

      if (response.user == null) {
        throw AppAuthException('Failed to authenticate user');
      }

      // Get user from database
      final user = await _userRepository.getUserById(response.user!.id);
      if (user == null) {
        throw AppAuthException('User not found');
      }

      // Check if user is blacklisted
      if (user.verification.isBlacklisted) {
        await logoutUser();
        throw AppAuthException(
            'Your account has been suspended. Please contact support.');
      }

      // Update last login
      await _userRepository.updateUserLastLogin(response.user!.id);

      // Store session token
      await _secureStorage.write(
        key: 'session_token',
        value: response.session?.persistSessionString,
      );

      return user;
    } catch (e) {
      if (e is AppAuthException) {
        rethrow;
      }
      throw AppAuthException(e.toString());
    }
  }

  Future<void> logoutUser() async {
    try {
      await _supabase.auth.signOut();
      await _secureStorage.delete(key: 'session_token');
    } catch (e) {
      throw AppAuthException(e.toString());
    }
  }

  Future<bool> resetPassword(String email) async {
    try {
      await _supabase.auth.resetPasswordForEmail(email);
      return true;
    } catch (e) {
      throw AppAuthException(e.toString());
    }
  }

  Future<bool> updatePassword({
    required String currentPassword,
    required String newPassword,
  }) async {
    try {
      if (newPassword.length < AppConstants.passwordMinLength) {
        throw AppAuthException(
            'Password must be at least ${AppConstants.passwordMinLength} characters long');
      }

      // Re-authenticate to validate current password
      final user = _supabase.auth.currentUser;
      if (user == null) {
        throw AppAuthException(
            'You need to be logged in to change your password');
      }

      // This is a workaround as Supabase doesn't have a direct "change password" method that checks old password
      // Instead, we try to sign in with current password to validate it
      await _supabase.auth.signInWithPassword(
        email: user.email!,
        password: currentPassword,
      );

      // Then update the password
      await _supabase.auth.updateUser(
        UserAttributes(password: newPassword),
      );

      // Also update the password hash in the database
      final passwordHash = _hashPassword(newPassword);
      await _userRepository.updateUserPassword(user.id, passwordHash);

      return true;
    } catch (e) {
      if (e is AppAuthException) {
        rethrow;
      }
      throw AppAuthException(e.toString());
    }
  }

  // Check if session is valid and restore it if needed
  Future<bool> restoreSession() async {
    try {
      final sessionToken = await _secureStorage.read(key: 'session_token');
      if (sessionToken == null) {
        return false;
      }

      final response = await _supabase.auth.recoverSession(sessionToken);
      return response.user != null;
    } catch (e) {
      await _secureStorage.delete(key: 'session_token');
      return false;
    }
  }

  // Get and check user type from current session
  Future<String?> getUserType() async {
    try {
      final user = _supabase.auth.currentUser;
      if (user == null) {
        return null;
      }

      final dbUser = await _userRepository.getUserById(user.id);
      return dbUser?.userType;
    } catch (e) {
      return null;
    }
  }

  // Check if a user is verified
  Future<bool> isUserVerified() async {
    try {
      final user = _supabase.auth.currentUser;
      if (user == null) {
        return false;
      }

      final dbUser = await _userRepository.getUserById(user.id);
      return dbUser?.isVerified ?? false;
    } catch (e) {
      return false;
    }
  }

  // Check if a user is blacklisted
  Future<bool> isUserBlacklisted() async {
    try {
      final user = _supabase.auth.currentUser;
      if (user == null) {
        return false;
      }

      final dbUser = await _userRepository.getUserById(user.id);
      return dbUser?.verification.isBlacklisted ?? false;
    } catch (e) {
      return false;
    }
  }
}
